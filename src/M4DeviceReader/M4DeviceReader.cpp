#include <thread>
#include <Gears.h>
#include <Version.h>
#include <string>
#include "ListOfDevices.h"
#include "PacketListener.h"
#include "M4DeviceReader.h"
#include "MakeSocketSetupItem.h"
#include "BaseDevice.h"
#include "M4Device.h"
#include <SocketSetupHelper.h>


using namespace std;

#pragma comment(lib, "Ws2_32.lib")

SocketSetupHelper mySocketSetupHelper;

SOCKET in;
sockaddr_in ServerAddress;
ListOfDevices MyList;

//ObjectHandle_v3 _person(kNullObjectHandle);

// Note:
// This file is partially autogenerated
// It is safe to make modifications to most of the file, however please don't modify the API function signatures
APIResult GEARS_API Component_Initialize(_In_ const char* component_folder)
{
  // GEARS NOTE: Use this function to perform component initialization.
  // Access to other components is unavailable.
    mySocketSetupHelper.myServerAddress = sockaddr_in();
    mySocketSetupHelper.mySocket = SOCKET();

    mySocketSetupHelper.WinSockSetup();
    mySocketSetupHelper.SocketSetup(in, ServerAddress);

  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API Component_OnStart(_In_ APIManager_v6* api_manager, _In_ NativeModuleHandle proxy_handle)
{
  // GEARS NOTE: Use this function to connect to other components.
  // Using the specified api_manager variable, this component can request access
  // to APIs that have been registered with Gears.

  // The Gears class will take care of requesting APIs for you. See Gears.h for more details.
  Gears::InitializeAPIs(api_manager, proxy_handle);

  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API Component_OnStop()
{
  // GEARS NOTE: Use this function to perform "last chance" functionality.
  // All components are still accessible.

  // Release all APIs and set them to nullptr.
  Gears::ReleaseAPIs();

  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API Component_Shutdown()
{
  // GEARS NOTE: Use this function to cleanup any resources that were allocated.
  // This component's shared library is about to be unloaded.
  // Access to other components is unavailable.
    WSACleanup();
  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API Component_IsParallelizable(_Out_ bool32_t* parallelizable)
{
  // GEARS NOTE: Set parallelizable to TRUE to enable this component's OnStart to be called from a spawned thread
  *parallelizable = TRUE;
  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API Component_GetName(_Inout_ int32_t* name_length, _Out_opt_ char* name)
{
  // GEARS NOTE: Use this function to fill out the name string with the name of the component.
  // Defaulted to return the official component name
  static const char* kComponentName = "M4DeviceReader";

  if(name_length == nullptr)
  {
    return kAPIResult_ParamsInvalid;
  }

  if(name == nullptr)
  {
    *name_length = static_cast<int32_t>(strlen(kComponentName) + 1);
  }
  else
  {
    strcpy_s(name, *name_length, kComponentName);
  }
  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API Component_GetVersion(_Inout_ int32_t* version_length, _Out_opt_ char* version)
{
  // GEARS NOTE: Use this function to fill out the version string with the version of the component.
  // Defaulted to return the auto generated/incremented version from Version.h
  static const char* kVersion = VERSION;

  if(version_length == nullptr)
  {
    return kAPIResult_ParamsInvalid;
  }

  if(version == nullptr)
  {
    *version_length = static_cast<int32_t>(strlen(kVersion) + 1);
  }
  else
  {
    strcpy_s(version, *version_length, kVersion);
  }
  return kAPIResult_GeneralSuccess;
}

//void GEARS_API ApplicationListener_OnBeforeUpdate(_In_ float32_t application_delta_time, _In_ float32_t simulation_delta_time)
//{
//    
    //PacketListener(MyList, in, ServerAddress);
// /*
//    if (Gears::API::MissionAPIv8()->GetPlayer(&_person) == kAPIResult_GeneralSuccess) {
//        if (Gears::API::WeaponSystemAspectAPIv11()->GetActiveWeapon(_person, &WeaponIndex, &MuzzleIndex, &MagazineIndex, &ModeIndex) == kAPIResult_GeneralSuccess) {
//            Gears::API::WeaponSystemAspectAPIv11()->EnableActiveWeaponSafety(_person, SafetyEnabled);
//            Gears::API::WeaponSystemAspectAPIv11()->SetActiveWeapon(_person, WeaponIndex, MuzzleIndex, MagazineIndex, FireMode);
//            if (Gears::API::WeaponSystemAspectAPIv11()->SetMagazineAmmoCount(_person, MagazineIndex, AmmoCount) == kAPIResult_GeneralSuccess) {
//                if (TimeToFire) {
//                    if (Gears::API::WeaponSystemAspectAPIv11()->FireActiveWeapon(_person, "") == kAPIResult_GeneralSuccess) {
//                        string message = "Device: " + CurrentDevice + " has fired in the loop!";
//                        const char* cstr = message.data();
//                        Gears::API::GUIAPIv3()->DisplayMessage(cstr);
//                        TimeToFire = false;
//                    }
//                }
//            }
//        }
//    }
//    */
//}

//void GEARS_API MissionListener_OnMissionStart(_In_ bool32_t restart)
//{
//    /*
//    Gears::API::GUIAPIv3()->DisplayMessage("Game Start!");
//
//    if (SocketIsReady == false) {
//        Gears::API::GUIAPIv3()->DisplayMessage("Yo, Either Winsock didn't work or there's already a socket listening at this port. Nothing in this component will work. Sorry!");
//    }
//    if (Gears::API::MissionAPIv8()->GetPlayer(&_person) == kAPIResult_GeneralSuccess)
//    {
//        Gears::API::GUIAPIv3()->DisplayMessage("Player Get!");
//    }
//    if (Gears::API::WeaponSystemAspectAPIv11()->GetActiveWeapon(_person, 0, 0, &MuzzleIndex, 0) == kAPIResult_GeneralSuccess)
//    {
//        Gears::API::GUIAPIv3()->DisplayMessage("Weapon Get!");
//    }
//    if (Gears::API::WeaponSystemAspectAPIv11()->SetMagazineAmmoCount(_person, MuzzleIndex, AmmoCount) == kAPIResult_GeneralSuccess)
//    {
//        Gears::API::GUIAPIv3()->DisplayMessage("Magazine Count Set!");
//    }
//    if (Gears::API::WeaponSystemAspectAPIv11()->EnableActiveWeaponSafety(_person, SafetyEnabled) == kAPIResult_GeneralSuccess)
//    {
//        Gears::API::GUIAPIv3()->DisplayMessage("Safety Set!");
//    }
//   */
//}



APIResult GEARS_API ComponentReloadingListener_BeforeUnload()
{
  // GEARS NOTE: Use this function to handle a component unload request.
  // This function is called before the component's OnStop and Shutdown functions have been invoked.
  // A component can use this opportunity to prevent the unload operation
  // from occuring by returning kAPIResult_DenyUnloadRequest.
  // A component that intends to unload can use this function to serialize
  // important state information that can be accessed upon being reloaded.
  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API ComponentReloadingListener_AfterReload(_In_ const char* component_folder)
{
  // GEARS NOTE: Use this function to handle a component reload request.
  // This function is called after the component's Initialize and OnStart functions have been invoked.
  // A component can use this opportunity to perform additional processing that is needed
  // in order for the component to once again operate as expected.
  return kAPIResult_GeneralSuccess;
}

//APIResult GEARS_API HaptechDevice_GetM4DeviceUsingStringAddress(_In_ const char* device_address, _Out_ void* device)
//{
//    
//    shared_ptr<BaseDevice> LatestDevice = MyList.DeviceDictionary.at(device_address);
//
//    device = &(MyList.DeviceDictionary.at(device_address));
//
//  return kAPIResult_GeneralSuccess;
//}

//APIResult GEARS_API HaptechDevice_name(_In_ int32_t hey, _Out_ int32_t* yo)
//{
//    int32_t heyzzz = 108;
//    Gears::API::GUIAPIv3()->DisplayMessage("Hello!");
//    *yo = heyzzz;
//  return kAPIResult_GeneralSuccess;
//}

//APIResult GEARS_API HaptechDevice_errorProneMaybe(_Out_ void* device)
//{
//    //device = &(MyList.DeviceDictionary.begin());
//
//  return kAPIResult_GeneralSuccess;
//}



APIResult GEARS_API HaptechDevice_test(_In_ const char* test_string, _In_ int32_t test_int)
{
    string myIntString = to_string(test_int);
    const char* cstr = myIntString.data();

    Gears::API::GUIAPIv3()->DisplayMessage(test_string);
    Gears::API::GUIAPIv3()->DisplayMessage(cstr);

  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API HaptechDevice_ParseDeviceUpdates()
{
    PacketListener(MyList, in, ServerAddress);

  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API HaptechDevice_GetDeviceState(_In_ const char* device_hex_address, _In_ const char* device_sensor, _Out_ int8_t* sensor_state)
{
    *sensor_state = 0;
    
       if (MyList.CheckIfAlreadyInTheList(device_hex_address))
       {
           shared_ptr<BaseDevice> LatestDevice = MyList.DeviceDictionary.at(device_hex_address);
    
           shared_ptr<M4Device> LatestM4Device = static_pointer_cast<M4Device>(LatestDevice);
          
           if (strcmp (device_sensor, "trigger") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->Trigger);
           }
    
           else if (strcmp(device_sensor, "hammer") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->Hammer);
           }
    
           else if (strcmp(device_sensor, "mag_release") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->MagRelease);
           }
    
           else if (strcmp(device_sensor, "bolt_catch") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->BoltCatch);
           }
    
           else if (strcmp(device_sensor, "safety") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->Safety);
           }
    
           else if (strcmp(device_sensor, "semi_auto") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->OnSemi);
           }
    
           else if (strcmp(device_sensor, "full_auto") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->OnAuto);
           }
    
           else if (strcmp(device_sensor, "chambered") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->Chambered);
           }
    
           else if (strcmp(device_sensor, "locked_to_rear") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->LockedBack);
           }
    
           else if (strcmp(device_sensor, "dummy_round") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->DummyRound);
           }
           
           else if (strcmp(device_sensor, "immediate_malfunction") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->ImmediateMalfunction);
           }
    
           else if (strcmp(device_sensor, "remedial_malfunction") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->RemedialMalfunction);
           }
    
           else if (strcmp(device_sensor, "current_ammo") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->CurrentAmmo);
           }
    
           else if (strcmp(device_sensor, "max_ammo") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->MaxAmmo);
           }
    
           else if (strcmp(device_sensor, "trigger_position") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->TriggerPosition);
           }
    
           else if (strcmp(device_sensor, "bolt_position") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->BoltPosition);
           }
    
           else if (strcmp(device_sensor, "charging_handle") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->ChargingHandlePulled);
           }
    
           else if (strcmp(device_sensor, "laser_enabled") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->LaserEnabled);
           }
    
           else if (strcmp(device_sensor, "laser_duration") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->LaserDuration);
           }
    
           else if (strcmp(device_sensor, "quiet_mode") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->QuietMode);
           }
   
           else if (strcmp(device_sensor, "accelerometer") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->AccelerometerEnabled);
           }
    
           else if (strcmp(device_sensor, "main_battery_percentage") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->MainBatteryPercentage);
           }
    
           else if (strcmp(device_sensor, "using_main_battery") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->UsingMainBattery);
           }
    
           else if (strcmp(device_sensor, "ready_to_fire") == 0)
           {
               *sensor_state = int8_t(LatestM4Device->ReadyToFire);
               MyList.DeviceDictionary.at(device_hex_address)->ReadyToFire = false;
           }
       }
    
       else {
           sensor_state = nullptr;

           //return kAPIResult_GeneralError;
       }

  return kAPIResult_GeneralSuccess;
}

void GEARS_API ApplicationListener_OnBeforeUpdate(_In_ float32_t application_delta_time, _In_ float32_t simulation_delta_time)
{
    PacketListener(MyList, in, ServerAddress);
    //Gears::API::GUIAPIv3()->DisplayMessage("Smash the update");
}

void GEARS_API ApplicationListener_OnApplicationReady()
{
}

void GEARS_API ApplicationListener_OnAfterUpdate(_In_ float32_t application_delta_time, _In_ float32_t simulation_delta_time)
{
}








