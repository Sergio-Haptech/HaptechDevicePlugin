#include <thread>
#include <Gears.h>
#include <Version.h>
#include <string>
#include "ListOfDevices.h"
#include "PacketListener.h"
#include "M4DeviceReader.h"
#include "MakeSocketSetupItem.h"
#include <SocketSetupHelper.h>


using namespace std;

#pragma comment(lib, "Ws2_32.lib")

SocketSetupHelper mySocketSetupHelper;

SOCKET in;
sockaddr_in ServerAddress;
ListOfDevices MyList;

bool SocketIsReady = true;
bool _started = true;

bool TimeToFire = false;
bool SafetyEnabled = false;
int FireMode = 0;

int MagazineIndex = 100;
int WeaponIndex = 100;
int ModeIndex = 100;
int DeviceIndex = 100;
int MuzzleIndex = 100;

int AmmoCount = 30;
string CurrentDevice = "hey";

ObjectHandle_v3 _person(kNullObjectHandle);

// Note:
// This file is partially autogenerated
// It is safe to make modifications to most of the file, however please don't modify the API function signatures
APIResult GEARS_API Component_Initialize(_In_ const char* component_folder)
{
  // GEARS NOTE: Use this function to perform component initialization.
  // Access to other components is unavailable.

  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API Component_OnStart(_In_ APIManager_v6* api_manager, _In_ NativeModuleHandle proxy_handle)
{
  // GEARS NOTE: Use this function to connect to other components.
  // Using the specified api_manager variable, this component can request access
  // to APIs that have been registered with Gears.

  // The Gears class will take care of requesting APIs for you. See Gears.h for more details.
  Gears::InitializeAPIs(api_manager, proxy_handle);

  mySocketSetupHelper.myServerAddress = sockaddr_in();
  mySocketSetupHelper.mySocket = SOCKET();

  mySocketSetupHelper.WinSockSetup();
  mySocketSetupHelper.SocketSetup(in, ServerAddress);

  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API Component_OnStop()
{
  // GEARS NOTE: Use this function to perform "last chance" functionality.
  // All components are still accessible.

  // Release all APIs and set them to nullptr.
  Gears::ReleaseAPIs();

  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API Component_Shutdown()
{
  // GEARS NOTE: Use this function to cleanup any resources that were allocated.
  // This component's shared library is about to be unloaded.
  // Access to other components is unavailable.
    WSACleanup();
  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API Component_IsParallelizable(_Out_ bool32_t* parallelizable)
{
  // GEARS NOTE: Set parallelizable to TRUE to enable this component's OnStart to be called from a spawned thread
  *parallelizable = TRUE;
  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API Component_GetName(_Inout_ int32_t* name_length, _Out_opt_ char* name)
{
  // GEARS NOTE: Use this function to fill out the name string with the name of the component.
  // Defaulted to return the official component name
  static const char* kComponentName = "M4DeviceReader";

  if(name_length == nullptr)
  {
    return kAPIResult_ParamsInvalid;
  }

  if(name == nullptr)
  {
    *name_length = static_cast<int32_t>(strlen(kComponentName) + 1);
  }
  else
  {
    strcpy_s(name, *name_length, kComponentName);
  }
  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API Component_GetVersion(_Inout_ int32_t* version_length, _Out_opt_ char* version)
{
  // GEARS NOTE: Use this function to fill out the version string with the version of the component.
  // Defaulted to return the auto generated/incremented version from Version.h
  static const char* kVersion = VERSION;

  if(version_length == nullptr)
  {
    return kAPIResult_ParamsInvalid;
  }

  if(version == nullptr)
  {
    *version_length = static_cast<int32_t>(strlen(kVersion) + 1);
  }
  else
  {
    strcpy_s(version, *version_length, kVersion);
  }
  return kAPIResult_GeneralSuccess;
}

void GEARS_API ApplicationListener_OnBeforeUpdate(_In_ float32_t application_delta_time, _In_ float32_t simulation_delta_time)
{
    PacketListener(MyList, in, ServerAddress);
    if (Gears::API::MissionAPIv8()->GetPlayer(&_person) == kAPIResult_GeneralSuccess) {
        if (Gears::API::WeaponSystemAspectAPIv11()->GetActiveWeapon(_person, &WeaponIndex, &MuzzleIndex, &MagazineIndex, &ModeIndex) == kAPIResult_GeneralSuccess) {
            Gears::API::WeaponSystemAspectAPIv11()->EnableActiveWeaponSafety(_person, SafetyEnabled);
            Gears::API::WeaponSystemAspectAPIv11()->SetActiveWeapon(_person, WeaponIndex, MuzzleIndex, MagazineIndex, FireMode);
            if (Gears::API::WeaponSystemAspectAPIv11()->SetMagazineAmmoCount(_person, MagazineIndex, AmmoCount) == kAPIResult_GeneralSuccess) {
                if (TimeToFire) {
                    if (Gears::API::WeaponSystemAspectAPIv11()->FireActiveWeapon(_person, "") == kAPIResult_GeneralSuccess) {
                        string message = "Device: " + CurrentDevice + " has fired in the loop!";
                        const char* cstr = message.data();
                        Gears::API::GUIAPIv3()->DisplayMessage(cstr);
                        TimeToFire = false;
                    }
                }
            }
        }
    }
}

void GEARS_API ApplicationListener_OnApplicationReady()
{

}

void GEARS_API ApplicationListener_OnAfterUpdate(_In_ float32_t application_delta_time, _In_ float32_t simulation_delta_time)
{
}

void GEARS_API MissionListener_OnPlayerSwitchedUnits(_In_ ObjectHandle_v3 old_entity, _In_ ObjectHandle_v3 new_entity)
{
}

void GEARS_API MissionListener_OnMissionUnload(_In_ const char* mission_name)
{
}

void GEARS_API MissionListener_OnMissionStart(_In_ bool32_t restart)
{
    Gears::API::GUIAPIv3()->DisplayMessage("Game Start!");

    if (SocketIsReady == false) {
        Gears::API::GUIAPIv3()->DisplayMessage("Yo, Either Winsock didn't work or there's already a socket listening at this port. Nothing in this component will work. Sorry!");
    }
    if (Gears::API::MissionAPIv8()->GetPlayer(&_person) == kAPIResult_GeneralSuccess)
    {
        Gears::API::GUIAPIv3()->DisplayMessage("Player Get!");
    }
    if (Gears::API::WeaponSystemAspectAPIv11()->GetActiveWeapon(_person, 0, 0, &MuzzleIndex, 0) == kAPIResult_GeneralSuccess)
    {
        Gears::API::GUIAPIv3()->DisplayMessage("Weapon Get!");
    }
    if (Gears::API::WeaponSystemAspectAPIv11()->SetMagazineAmmoCount(_person, MuzzleIndex, AmmoCount) == kAPIResult_GeneralSuccess)
    {
        Gears::API::GUIAPIv3()->DisplayMessage("Magazine Count Set!");
    }
    if (Gears::API::WeaponSystemAspectAPIv11()->EnableActiveWeaponSafety(_person, SafetyEnabled) == kAPIResult_GeneralSuccess)
    {
        Gears::API::GUIAPIv3()->DisplayMessage("Safety Set!");
    }
   
}

void GEARS_API MissionListener_OnMissionLoad(_In_ const char* mission_name)
{
}

void GEARS_API MissionListener_OnMissionEnd(_In_ bool32_t restart)
{
}

void GEARS_API MissionListener_OnBriefingShowRequest()
{
}

void GEARS_API MissionListener_OnBriefingHideRequest()
{
}

void GEARS_API WeaponSystemAspectListener_OnWeaponChanged(_In_ ObjectHandle_v3 weapon_system_owner, _In_ int32_t previous_weapon_index, _In_ int32_t new_weapon_index)
{
}

void GEARS_API WeaponSystemAspectListener_OnWeaponAddedOrRemoved(_In_ ObjectHandle_v3 weapon_system_owner, _In_ const char* weapon_name, _In_ int32_t count)
{
}

void GEARS_API WeaponSystemAspectListener_OnMuzzleChanged(_In_ ObjectHandle_v3 weapon_system_owner, _In_ int32_t weapon_index, _In_ int32_t previous_muzzle_index, _In_ int32_t new_muzzle_index)
{
}

void GEARS_API WeaponSystemAspectListener_OnMagazineChanged(_In_ ObjectHandle_v3 weapon_system_owner, _In_ int32_t weapon_index, _In_ int32_t previous_magazine_index, _In_ int32_t new_magazine_index)
{
}

void GEARS_API WeaponSystemAspectListener_OnMagazineAddedOrRemoved(_In_ ObjectHandle_v3 weapon_system_owner, _In_ const char* magazine_name, _In_ int32_t count)
{
}

void GEARS_API WeaponSystemAspectListener_OnIncomingProjectile(_In_ ObjectHandle_v3 object, _In_ ObjectHandle_v3 projectile, _In_ float32_t distance, _In_ GeoPosition_v5 projectile_position, _In_ Vector3f32_v3 projectile_velocity, _In_ ObjectHandle_v3 shooter, _In_ bool32_t can_damage, _In_ GeoPosition_v5 projectile_origin_position)
{
}

void GEARS_API WeaponSystemAspectListener_OnIncomingLaser(_In_ ObjectHandle_v3 lased_object, _In_ ObjectHandle_v3 laser_source, _In_ LaserType_v5 laser_type, _In_ int64_t lase_event_id, _In_ bool32_t end_of_lase_event, _In_ RotationalAngles_v3 laser_direction, _In_ GeoPosition_v5 laser_position, _In_ float32_t laser_cone_angle)
{
}

void GEARS_API WeaponSystemAspectListener_OnFire(_In_ ObjectHandle_v3 shooter_lifeform, _In_ ObjectHandle_v3 shooter_platform, _In_ ObjectHandle_v3 shooter_turret, _In_ ObjectHandle_v3 shot)
{
}

void GEARS_API WeaponSystemAspectListener_OnAmmoHit(_In_ const HitEvent_v3* hit_info)
{
}

APIResult GEARS_API ComponentReloadingListener_BeforeUnload()
{
  // GEARS NOTE: Use this function to handle a component unload request.
  // This function is called before the component's OnStop and Shutdown functions have been invoked.
  // A component can use this opportunity to prevent the unload operation
  // from occuring by returning kAPIResult_DenyUnloadRequest.
  // A component that intends to unload can use this function to serialize
  // important state information that can be accessed upon being reloaded.
  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API ComponentReloadingListener_AfterReload(_In_ const char* component_folder)
{
  // GEARS NOTE: Use this function to handle a component reload request.
  // This function is called after the component's Initialize and OnStart functions have been invoked.
  // A component can use this opportunity to perform additional processing that is needed
  // in order for the component to once again operate as expected.
  return kAPIResult_GeneralSuccess;
}

APIResult GEARS_API HaptechDevice_GetM4DeviceUsingStringAddress(_Out_ void* device)
{
  return kAPIResult_GeneralSuccess;
}






